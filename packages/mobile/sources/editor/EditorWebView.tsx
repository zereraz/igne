/**
 * EditorWebView — CodeMirror 6 editor in a React Native WebView.
 *
 * Uses the pre-built editorBundle.ts (generated by scripts/build-editor.mjs)
 * which contains all CM6 extensions inlined into a single HTML string.
 *
 * Bridge protocol:
 *   RN → WebView: setContent, setTheme, focus
 *   WebView → RN: contentChange, wikilinkClick, ready
 */

import { useEffect, useRef, useCallback } from 'react';
import { WebView, type WebViewMessageEvent } from 'react-native-webview';
import { EDITOR_HTML } from './editorBundle';

interface EditorWebViewProps {
  content: string;
  theme: 'dark' | 'light';
  onChange: (content: string) => void;
  onWikilinkClick?: (target: string) => void;
  onReady?: () => void;
  style?: object;
}

export function EditorWebView({
  content,
  theme,
  onChange,
  onWikilinkClick,
  onReady,
  style,
}: EditorWebViewProps) {
  const webviewRef = useRef<WebView>(null);
  const isReadyRef = useRef(false);
  const pendingContentRef = useRef<string | null>(content);

  const sendMessage = useCallback((msg: Record<string, unknown>) => {
    webviewRef.current?.postMessage(JSON.stringify(msg));
  }, []);

  // Send content to editor when ready or when content changes externally
  useEffect(() => {
    if (isReadyRef.current) {
      sendMessage({ type: 'setContent', content, theme });
    } else {
      pendingContentRef.current = content;
    }
  }, [content, sendMessage, theme]);

  // Send theme changes
  useEffect(() => {
    if (isReadyRef.current) {
      sendMessage({ type: 'setTheme', theme });
    }
  }, [theme, sendMessage]);

  const handleMessage = useCallback(
    (event: WebViewMessageEvent) => {
      try {
        const msg = JSON.parse(event.nativeEvent.data);
        switch (msg.type) {
          case 'contentChange':
            onChange(msg.content);
            break;
          case 'wikilinkClick':
            onWikilinkClick?.(msg.target);
            break;
          case 'ready':
            isReadyRef.current = true;
            if (pendingContentRef.current !== null) {
              sendMessage({
                type: 'setContent',
                content: pendingContentRef.current,
                theme,
              });
              pendingContentRef.current = null;
            }
            onReady?.();
            break;
        }
      } catch {
        // Ignore parse errors
      }
    },
    [onChange, onWikilinkClick, onReady, theme, sendMessage]
  );

  return (
    <WebView
      ref={webviewRef}
      source={{ html: EDITOR_HTML, baseUrl: '' }}
      onMessage={handleMessage}
      style={[{ flex: 1 }, style]}
      scrollEnabled={true}
      keyboardDisplayRequiresUserAction={false}
      hideKeyboardAccessoryView={false}
      allowsInlineMediaPlayback={true}
      originWhitelist={['*']}
      javaScriptEnabled={true}
      domStorageEnabled={true}
    />
  );
}
