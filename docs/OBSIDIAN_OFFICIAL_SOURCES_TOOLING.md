# Obsidian official sources tooling (compat + research)

This repo aims to be an OSS Obsidian “drop-in” replacement. To do that without drowning in guesswork, we continuously sync against **official upstream sources** and keep the results as **auditable artifacts** in-repo.

This document explains:

- what the tooling is
- which official sources it pulls from
- what guarantees it enforces (and why that keeps the codebase sane)
- how to run it + how to interpret outputs

## What “official sources” means here

Igne uses the following upstream sources as the grounding truth:

1. **Obsidian plugin API contract (official)** via npm package `obsidian` (types):  
   `compat/obsidian-api/obsidian.d.ts`
2. **Community ecosystem lists (official)** via `obsidianmd/obsidian-releases` (raw JSON):  
   `research-oss/obsidian-research/community-plugins.json`  
   `research-oss/obsidian-research/community-plugin-stats.json`  
   `research-oss/obsidian-research/community-css-themes.json`

The URL registry lives in one place:

- `compat/obsidian-upstream/sources.json`

If upstream URLs ever move, update *that* file, not every script.

## Why this helps (what problems it solves)

### 1) Keeps compatibility work anchored to a concrete contract

The vendored `obsidian.d.ts` is the **declared compatibility surface** for community plugins.

This prevents “vibe-coded compatibility” where we accidentally implement a drifting, undocumented API that’s incompatible with real plugins.

### 2) Makes upstream changes mechanical to handle

When Obsidian updates their types, you can:

- preview the diff
- store the diff as a patch
- update the vendored contract
- turn the diff into tasks + tests

This is how you keep “support everything” feasible over time.

### 3) Prevents repo-wide drift and hidden regressions

The invariant checks are **guardrails** against the failure mode where compat glue spreads everywhere:

- frontend invoking backend commands that don’t exist
- accidental `.obsidian/...` relative paths (breaks multi-vault + portability)
- frontend using `process.platform` (breaks in-browser assumptions)
- backend hardcoding directory recursion depth (breaks plugins/themes/attachments)

### 4) Keeps research/prioritization grounded in the real ecosystem

The community datasets are used to generate rankings (top plugins + AI plugins) which inform:

- what workflows matter most
- what “drop-in” really means in practice
- what to prioritize in `docs/OBSIDIAN_DROP_IN_GAP_REPORT.md`

## Where outputs live (artifacts)

### Contract (API)

- `compat/obsidian-api/obsidian.d.ts` — vendored Obsidian plugin API typings
- `compat/obsidian-api/metadata.json` — version + sha256/bytes for the vendored contract
- `compat/obsidian-api/diffs/` — optional saved patches between versions (generated by preview command)

### Official ecosystem datasets (research)

- `research-oss/obsidian-research/community-plugins.json`
- `research-oss/obsidian-research/community-plugin-stats.json`
- `research-oss/obsidian-research/community-css-themes.json`
- `research-oss/obsidian-research/official-snapshot.json` — sha256/bytes + HTTP headers (etag/last-modified) for auditability

### Derived summaries (generated)

- `research-oss/obsidian-research/TOP_PLUGINS_BY_DOWNLOADS.md`
- `research-oss/obsidian-research/TOP_AI_PLUGINS_BY_DOWNLOADS.md`

## Commands (what to run)

All commands below are wired in `package.json`.

### Compat enforcement

- `npm run check:compat`
  - runs: contract check + invariants check
  - use this before merging any compatibility-related changes

### Contract management (API)

- `npm run obsidian:check-contract`
  - verifies `compat/obsidian-api/obsidian.d.ts` matches `compat/obsidian-api/metadata.json`

- `npm run obsidian:preview-contract-update -- --tag latest`
  - downloads the target version and prints a diff vs current vendored contract
  - add `--write` to save a patch to `compat/obsidian-api/diffs/`

- `npm run obsidian:update-contract -- --tag latest`
  - updates `compat/obsidian-api/obsidian.d.ts` + `compat/obsidian-api/metadata.json`

### Official ecosystem refresh (research inputs)

- `npm run obsidian:update-community-data`
  - refreshes the official Obsidian community JSON files into `research-oss/obsidian-research/`

- `npm run obsidian:generate-plugin-rankings`
  - regenerates `TOP_PLUGINS_BY_DOWNLOADS.md` + `TOP_AI_PLUGINS_BY_DOWNLOADS.md` from the local JSON files

- `npm run obsidian:update-research`
  - runs `obsidian:update-community-data` + `obsidian:generate-plugin-rankings`

## “Does it work?” (verification)

The tooling is designed so you can validate it quickly:

1. `npm run check:compat`
2. `npm run obsidian:update-research`
3. `npm run obsidian:preview-contract-update -- --tag latest`

If those succeed, you’ve verified:
- Type contract lock is intact
- Repo invariants are enforced
- Official datasets can be fetched + re-derived
- Contract diffing is functional

## Runtime notes (Node vs Bun)

Scripts are written in TypeScript under `scripts/obsidian/`.

- Node runner: `node --experimental-strip-types` (wired via `package.json`)
- Bun runner: you can run any script directly, e.g. `bun scripts/obsidian/update-contract.ts`

## How to use this in day-to-day compatibility work

### When adding/adjusting backend commands

1. Implement Rust command + add to `generate_handler![]`
2. Run `npm run check:compat` (catches missing command wiring)

### When touching `.obsidian/*` behavior

1. Ensure paths are vault-resolved (never relative)
2. Run `npm run check:compat` (catches relative `.obsidian/...` invoke usage)

### When Obsidian updates

1. `npm run obsidian:preview-contract-update -- --tag latest`
2. Save patch if interesting: re-run with `--write`
3. `npm run obsidian:update-contract -- --tag latest`
4. Convert diffs into tasks + tests (then update `docs/OBSIDIAN_DROP_IN_GAP_REPORT.md`)

