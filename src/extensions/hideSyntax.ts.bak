import { Extension } from '@codemirror/state';
import { EditorView } from '@codemirror/view';
import { ViewPlugin, Decoration, DecorationSet } from '@codemirror/view';
import { syntaxTree } from '@codemirror/language';

export interface HideSyntaxConfig {
  enabled?: boolean;
  onToggle?: (enabled: boolean) => void;
}

let hideSyntaxEnabled = false;
let toggleCallback: ((enabled: boolean) => void) | null = null;

function buildHideDecorations(view: EditorView): DecorationSet {
  if (!hideSyntaxEnabled) {
    return Decoration.set([]);
  }

  const decorations: any[] = [];
  const { head: cursor } = view.state.selection.main;
  const cursorLine = view.state.doc.lineAt(cursor).number;

  syntaxTree(view.state).iterate({
    enter(node) {
      const nodeLine = view.state.doc.lineAt(node.from).number;

      // Don't hide syntax on the current line
      if (nodeLine === cursorLine) {
        return;
      }

      // Hide markdown syntax marks
      if (
        node.name === 'HeaderMark' ||
        node.name === 'EmphasisMark' ||
        node.name === 'CodeMark' ||
        node.name === 'LinkMark' ||
        node.name === 'StrikethroughMark' ||
        node.name === 'HighlightMark' ||
        node.name === 'URL' ||
        node.name === 'ListMark' ||
        node.name === 'QuoteMark' ||
        node.name === 'WikilinkMark' ||
        node.name === 'EmbedMark' ||
        node.name === 'TagMark'
      ) {
        decorations.push(
          Decoration.replace({ isHidden: true }).range(node.from, node.to)
        );
      }
    },
  });

  return Decoration.set(decorations);
}

export function createHideSyntax(config: HideSyntaxConfig = {}) {
  return ViewPlugin.fromClass(
    class {
      decorations: DecorationSet;

      constructor(view: EditorView) {
        this.decorations = buildHideDecorations(view);
      }

      update(update: any) {
        if (update.docChanged || update.selectionSet || update.viewportChanged) {
          this.decorations = buildHideDecorations(update.view);
        }
      }
    },
    { decorations: (v: any) => v.decorations }
  );
}

export function toggleHideSyntax(): Extension[] {
  hideSyntaxEnabled = !hideSyntaxEnabled;
  if (toggleCallback) {
    toggleCallback(hideSyntaxEnabled);
  }
  return [createHideSyntax({})];
}

export function isHideSyntaxEnabled(): boolean {
  return hideSyntaxEnabled;
}

export function setHideSyntaxEnabled(enabled: boolean): void {
  hideSyntaxEnabled = enabled;
  if (toggleCallback) {
    toggleCallback(enabled);
  }
}

export function setToggleCallback(callback: (enabled: boolean) => void): void {
  toggleCallback = callback;
}
